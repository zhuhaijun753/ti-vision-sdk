<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.family.arm.cc26xx.Power</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2012-2015, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Power.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> *
</span>    36    <span class="comment"> */</span>
    37    
    38    <span class=key>package</span> ti.sysbios.family.arm.cc26xx;
    39    
    40    import xdc.rov.ViewInfo;
    41    
    42    import xdc.runtime.Assert;
    43    import ti.sysbios.knl.Queue;
    44    import ti.sysbios.knl.Clock;
    45    
    46    <span class="xdoc">/*!
</span>    47    <span class="xdoc"> *  ======== Power ========
</span>    48    <span class="xdoc"> *  CC26xx Power Manager
</span>    49    <span class="xdoc"> *
</span>    50    <span class="xdoc"> *  <b>@p(html)</b>
</span>    51    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>    52    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>    53    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;&lt;/colgroup&gt;
</span>    54    <span class="xdoc"> *
</span>    55    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                 &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;&lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>    56    <span class="xdoc"> *    &lt;!-- --&gt;
</span>    57    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getConstraintInfo}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    58    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getDependencyCount}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    59    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTicksUntilWakeup}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    60    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTransitionLatency}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    61    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTransitionState}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    62    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getXoscStartupTime}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    63    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #registerNotify}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    64    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #releaseConstraint}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    65    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #releaseDependency}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    66    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setConstraint}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    67    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setDependency}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    68    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #shutdown}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    69    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #sleep}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    70    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #unregisterNotify}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    71    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>    72    <span class="xdoc"> *       &lt;ul&gt;
</span>    73    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread &lt;/li&gt;
</span>    74    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread &lt;/li&gt;
</span>    75    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread &lt;/li&gt;
</span>    76    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable from main() &lt;/li&gt;
</span>    77    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any module startup &lt;/li&gt;
</span>    78    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Y&lt;/b&gt;: Yes &lt;/li&gt;
</span>    79    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Y*&lt;/b&gt;: Yes, but see API description for restrictions &lt;/li&gt;
</span>    80    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;N&lt;/b&gt;: No &lt;/li&gt;
</span>    81    <span class="xdoc"> *       &lt;/ul&gt;
</span>    82    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>    83    <span class="xdoc"> *
</span>    84    <span class="xdoc"> *  &lt;/table&gt;
</span>    85    <span class="xdoc"> *  <b>@p</b>
</span>    86    <span class="xdoc"> */</span>
    87    
    88    @ModuleStartup            <span class="comment">/* Initialize Power */</span>
    89    
    90    <span class=key>module</span> Power <span class=key>inherits</span> ti.sysbios.interfaces.IPower
    91    {
    92        <span class="xdoc">/*! <b>@_nodoc</b> Idle function prototype */</span>
    93        <span class=key>typedef</span> Void (*FuncPtr)();
    94    
    95        <span class="xdoc">/*!
</span>    96    <span class="xdoc">     *  ======== Constraint ========
</span>    97    <span class="xdoc">     *  Constraints that can be registered with Power
</span>    98    <span class="xdoc">     */</span>
    99        <span class=key>enum</span> Constraint {
   100            SB_VIMS_CACHE_RETAIN      = 0x1, <span class="xdoc">/*! disallow loss of cache context during Power_STANDBY (i.e., retain the cache) */</span>
   101            SD_DISALLOW               = 0x2, <span class="xdoc">/*! disallow transition to SHUTDOWN */</span>
   102            SB_DISALLOW               = 0x4,<span class="xdoc">/*! disallow transition to Power_STANDBY */</span>
   103            IDLE_PD_DISALLOW          = 0x8,<span class="xdoc">/*! disallow power down of the CPU domain during idle time (IDLE_PD) */</span>
   104            NEED_FLASH_IN_IDLE        = 0x10,<span class="xdoc">/*! need to keep Flash powered in IDLE_PD */</span>
   105            NUMCONSTRAINTS = 5
   106        };
   107    
   108        <span class="xdoc">/*!
</span>   109    <span class="xdoc">     *  ======== LatencyType ========
</span>   110    <span class="xdoc">     *  Type of transition latency to query
</span>   111    <span class="xdoc">     */</span>
   112        <span class=key>enum</span> LatencyType {
   113            TOTAL,   <span class="xdoc">/*! the total latency, to enter the sleep state, and to wake and resume */</span>
   114            RESUME   <span class="xdoc">/*! the latency to wake the device and resume execution */</span>
   115        };
   116    
   117        <span class="xdoc">/*!
</span>   118    <span class="xdoc">     *  ======== SleepState ========
</span>   119    <span class="xdoc">     *  Sleep states
</span>   120    <span class="xdoc">     */</span>
   121        <span class=key>enum</span> SleepState {
   122            STANDBY = 0x1   <span class="xdoc">/*! STANDBY state */</span>
   123        };
   124    
   125        <span class="xdoc">/*!
</span>   126    <span class="xdoc">     *  ======== Event ========
</span>   127    <span class="xdoc">     *  Power Event enumerations
</span>   128    <span class="xdoc">     */</span>
   129        <span class=key>enum</span> Event {
   130            ENTERING_STANDBY          = 0x1, <span class="xdoc">/*! device is transitioning into Power_STANDBY */</span>
   131            ENTERING_SHUTDOWN         = 0x2, <span class="xdoc">/*! device is transitioning into SHUTDOWN */</span>
   132            AWAKE_STANDBY             = 0x4, <span class="xdoc">/*! device has awoken from Power_STANDBY, I/O latches are still frozen */</span>
   133            AWAKE_STANDBY_LATE        = 0x8, <span class="xdoc">/*! device has awoken from Power_STANDBY, I/O latches are open again */</span>
   134            XOSC_HF_SWITCHED          = 0x10, <span class="xdoc">/*! the high frequency (HF) crystal oscillator has stabilized, and is now the HF clock source */</span>
   135            NUMEVENTS = 5
   136        };
   137    
   138        <span class="xdoc">/*!
</span>   139    <span class="xdoc">     *  ======== NotifyResponse ========
</span>   140    <span class="xdoc">     *  Return values from a notify function.
</span>   141    <span class="xdoc">     */</span>
   142        <span class=key>enum</span> NotifyResponse {
   143            NOTIFYDONE = 0,<span class="xdoc">/*! success, done processing the notification */</span>
   144            NOTIFYERROR   <span class="xdoc">/*! an error occurred while processing the notification */</span>
   145        };
   146    
   147        <span class="xdoc">/*! <b>@_nodoc</b> ResourceRecord structure */</span>
   148        <span class=key>struct</span> ResourceRecord {
   149            UInt8 flags;          <span class="comment">/* resource type : first parent */</span>
   150            UInt8 flags2;         <span class="comment">/* second parent */</span>
   151            UInt16 driverlibID;   <span class="comment">/* driverlib ID for the resource */</span>
   152        };
   153    
   154        <span class="xdoc">/*!
</span>   155    <span class="xdoc">     *  ======== Status ========
</span>   156    <span class="xdoc">     *  Function return codes
</span>   157    <span class="xdoc">     */</span>
   158        <span class=key>enum</span> Status {
   159            SOK = 0,                <span class="xdoc">/*! success */</span>
   160            SOK_STATE_RESTORED = 1, <span class="xdoc">/*! success, context has been restored */</span>
   161            EFAIL = 2,              <span class="xdoc">/*! error, the operation failed */</span>
   162            EINVALIDPOINTER = 3,    <span class="xdoc">/*! error, an invalid pointer was specified */</span>
   163            ECHANGE_NOT_ALLOWED = 4,<span class="xdoc">/*! error, the requested change is not allowed */</span>
   164            ETIMEOUT = 5,           <span class="xdoc">/*! error, a timeout occurred */</span>
   165            EBUSY = 6               <span class="xdoc">/*! error, the operation is not allowed; another transition is not completed yet */</span>
   166        };
   167    
   168        <span class="xdoc">/*!
</span>   169    <span class="xdoc">     *  ======== TransitionState ========
</span>   170    <span class="xdoc">     *  Sleep transition states
</span>   171    <span class="xdoc">     */</span>
   172        <span class=key>enum</span> TransitionState {
   173            ACTIVE = 0x1,        <span class="xdoc">/*! device is active; no transition in progress */</span>
   174            ENTERING_SLEEP = 0x2,<span class="xdoc">/*! device is entering into a sleep state */</span>
   175            EXITING_SLEEP = 0x3, <span class="xdoc">/*! device is exiting a sleep state */</span>
   176            SHUTDOWN = 0x4 <span class="xdoc">/*! device is transitioning to the SHUTDOWN state */</span>
   177        };
   178    
   179        <span class="xdoc">/*! <b>@_nodoc</b> Notification object structure. */</span>
   180        <span class=key>struct</span> NotifyObj {
   181            Queue.Elem link;
   182            UInt32 eventTypes;
   183            Fxn notifyFxn;
   184            UArg clientArg;
   185        };
   186    
   187        <span class=comment>// Asserts</span>
   188    
   189        <span class="xdoc">/*! Assert when Power_releaseConstraint is called too many times */</span>
   190        <span class=key>config</span> Assert.Id A_tooManyCallsReleaseConstraint = {
   191            msg: <span class="string">"A_tooManyCallsReleaseConstraint: Power_releaseConstraint() called too many times for this constraint."</span>
   192        };
   193    
   194        <span class="xdoc">/*! Assert when Power_releaseDependency is called too many times */</span>
   195        <span class=key>config</span> Assert.Id A_tooManyCallsReleaseDependency = {
   196            msg: <span class="string">"A_tooManyCallsReleaseDependency: Power_releaseDependency() called too many times for this resource."</span>
   197        };
   198    
   199        <span class=comment>// configs</span>
   200    
   201        <span class="xdoc">/*!
</span>   202    <span class="xdoc">     *  ======== idle ========
</span>   203    <span class="xdoc">     *  Idle the CPU during idle time?
</span>   204    <span class="xdoc">     *
</span>   205    <span class="xdoc">     *  When this configuration parameter is set to true, the Power module will
</span>   206    <span class="xdoc">     *  insert a power policy function into the list of {<b>@link</b>
</span>   207    <span class="xdoc">     *  ti.sysbios.knl.Idle Idle} loop functions.
</span>   208    <span class="xdoc">     *  When the policy function executes, it will take action to save power
</span>   209    <span class="xdoc">     *  until the next CPU interrupt occurs.  The default power policy will
</span>   210    <span class="xdoc">     *  simply invoke a wait for interrupt (WFI) instruction.
</span>   211    <span class="xdoc">     *
</span>   212    <span class="xdoc">     *  <b>@see</b> #policyFunc
</span>   213    <span class="xdoc">     *  <b>@see</b> #doWFI
</span>   214    <span class="xdoc">     *  <b>@see</b> #standbyPolicy
</span>   215    <span class="xdoc">     */</span>
   216        <span class=key>override</span> <span class=key>config</span> Bool idle = <span class=key>false</span>;
   217    
   218        <span class="xdoc">/*!
</span>   219    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   220    <span class="xdoc">     *  ======== resumeSTANDBY ========
</span>   221    <span class="xdoc">     *  Latency to resume from STANDBY (in microseconds).
</span>   222    <span class="xdoc">     *  NB: this is a temporary value pending further characterization.
</span>   223    <span class="xdoc">     */</span>
   224        <span class=key>metaonly</span> <span class=key>config</span> UInt resumeSTANDBY = 750;
   225    
   226        <span class="xdoc">/*!
</span>   227    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   228    <span class="xdoc">     *  ======== resumeTicksSTANDBY ========
</span>   229    <span class="xdoc">     *  Latency to resume from STANDBY (in units of Clock ticks).
</span>   230    <span class="xdoc">     */</span>
   231        <span class=key>config</span> UInt resumeTicksSTANDBY;
   232    
   233        <span class="xdoc">/*!
</span>   234    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   235    <span class="xdoc">     *  ======== totalSTANDBY ========
</span>   236    <span class="xdoc">     *  Total latency to enter and resume from STANDBY (in microseconds).
</span>   237    <span class="xdoc">     *  NB: this is a temporary value pending further characterization.
</span>   238    <span class="xdoc">     */</span>
   239        <span class=key>metaonly</span> <span class=key>config</span> UInt totalSTANDBY = 1000;
   240    
   241        <span class="xdoc">/*!
</span>   242    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   243    <span class="xdoc">     *  ======== totalTicksSTANDBY ========
</span>   244    <span class="xdoc">     *  Total latency to enter and resume from STANDBY (in units of Clock
</span>   245    <span class="xdoc">     *  ticks).
</span>   246    <span class="xdoc">     */</span>
   247        <span class=key>config</span> UInt totalTicksSTANDBY;
   248    
   249        <span class="xdoc">/*!
</span>   250    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   251    <span class="xdoc">     *  ======== wakeDelaySTANDBY ========
</span>   252    <span class="xdoc">     *  Device initial wakeup latency from STANDBY (in units of microseconds).
</span>   253    <span class="xdoc">     */</span>
   254        <span class=key>config</span> UInt wakeDelaySTANDBY = 130;
   255    
   256        <span class="xdoc">/*!
</span>   257    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   258    <span class="xdoc">     *  ======== initialWaitXOSC_HF ========
</span>   259    <span class="xdoc">     *  Time (in units of usec) to wait to see if XOSC_HF is stable.
</span>   260    <span class="xdoc">     */</span>
   261        <span class=key>config</span> UInt initialWaitXOSC_HF = 50;
   262    
   263        <span class="xdoc">/*!
</span>   264    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   265    <span class="xdoc">     *  ======== retryWaitXOSC_HF ========
</span>   266    <span class="xdoc">     *  Time (in units of usec) to wait when retrying to see if XOSC_HF is
</span>   267    <span class="xdoc">     *   stable.
</span>   268    <span class="xdoc">     */</span>
   269        <span class=key>config</span> UInt retryWaitXOSC_HF = 50;
   270    
   271        <span class="xdoc">/*!
</span>   272    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   273    <span class="xdoc">     *  ======== calibrateRCOSC ========
</span>   274    <span class="xdoc">     *  Enable RCOSC calibration?   Default is true.
</span>   275    <span class="xdoc">     */</span>
   276        <span class=key>config</span> Bool calibrateRCOSC = <span class=key>true</span>;
   277    
   278        <span class="xdoc">/*!
</span>   279    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   280    <span class="xdoc">     *  ======== calibrateRCOSC_LF ========
</span>   281    <span class="xdoc">     *  Enable RCOSC_LF calibration?  Default is true;
</span>   282    <span class="xdoc">     */</span>
   283        <span class=key>config</span> Bool calibrateRCOSC_LF = <span class=key>true</span>;
   284    
   285        <span class="xdoc">/*!
</span>   286    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   287    <span class="xdoc">     *  ======== calibrateRCOSC_HF ========
</span>   288    <span class="xdoc">     *  Enable RCOSC_HF calibration?  Default is true;
</span>   289    <span class="xdoc">     */</span>
   290        <span class=key>config</span> Bool calibrateRCOSC_HF = <span class=key>true</span>;
   291    
   292        <span class="xdoc">/*!
</span>   293    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   294    <span class="xdoc">     *   Wakeup Clock object's function.  Default is Power_defaultClockFunc.
</span>   295    <span class="xdoc">     */</span>
   296        <span class=key>config</span> Clock.FuncPtr clockFunc = Power.defaultClockFunc;
   297    
   298        <span class="xdoc">/*! Policy function.  Default is Power_doWFI. */</span>
   299        <span class=key>metaonly</span> <span class=key>config</span> FuncPtr policyFunc = Power.doWFI;
   300    
   301        <span class="xdoc">/*!
</span>   302    <span class="xdoc">     * <b>@_nodoc</b>
</span>   303    <span class="xdoc">     *  Notify trap function.  Default is Power.defaultNotifyTrapFunc.
</span>   304    <span class="xdoc">     */</span>
   305        <span class=key>config</span> FuncPtr notifyTrapFunc = Power.defaultNotifyTrapFunc;
   306    
   307        <span class=comment>// module functions</span>
   308    
   309        <span class="xdoc">/*!
</span>   310    <span class="xdoc">     *  ======== standbyPolicy ========
</span>   311    <span class="xdoc">     *  A power policy function that will transition the device into the
</span>   312    <span class="xdoc">     *  Power_STANDBY sleep state during CPU idle time.
</span>   313    <span class="xdoc">     *
</span>   314    <span class="xdoc">     *  This is an agressive power policy function that will consider active
</span>   315    <span class="xdoc">     *  constraints, sleep transition latencies, and the next expected wakeup,
</span>   316    <span class="xdoc">     *  and automatically transition the device into the deepest sleep state
</span>   317    <span class="xdoc">     *  possible.
</span>   318    <span class="xdoc">     *
</span>   319    <span class="xdoc">     *  The first goal is to enter Power_STANDBY; if that is not appropriate
</span>   320    <span class="xdoc">     *  given current conditions (e.g., the sleep transition latency is
</span>   321    <span class="xdoc">     *  greater than the time until the next scheduled Clock event), then
</span>   322    <span class="xdoc">     *  the secondary goal is the IDLE_PD state; if that is disallowed (e.g.,
</span>   323    <span class="xdoc">     *  if the Power_IDLE_PD_DISALLOW constraint is declared), then the policy
</span>   324    <span class="xdoc">     *  will fallback and simply invoke wait-for-interrupt, to clock
</span>   325    <span class="xdoc">     *  gate the CPU until the next interrupt.
</span>   326    <span class="xdoc">     *
</span>   327    <span class="xdoc">     *  This policy is enabled and selected via the following application
</span>   328    <span class="xdoc">     *  configuration steps:
</span>   329    <span class="xdoc">     *
</span>   330    <span class="xdoc">     *  <b>@p(code)</b>
</span>   331    <span class="xdoc">     *  Power.idle = true;
</span>   332    <span class="xdoc">     *  Power.policyFunc = Power.standbyPolicy;
</span>   333    <span class="xdoc">     *  <b>@p</b>
</span>   334    <span class="xdoc">     */</span>
   335        Void standbyPolicy();
   336    
   337        <span class="xdoc">/*!
</span>   338    <span class="xdoc">     * <b>@_nodoc</b>
</span>   339    <span class="xdoc">     *  ======== defaultClockFunc ========
</span>   340    <span class="xdoc">     *  Function for the Clock object dedicated for scheduling wakeups.
</span>   341    <span class="xdoc">     */</span>
   342        Void defaultClockFunc(UArg arg);
   343    
   344        <span class="xdoc">/*!
</span>   345    <span class="xdoc">     * <b>@_nodoc</b>
</span>   346    <span class="xdoc">     *  ======== defaultNotifyTrapFunc ========
</span>   347    <span class="xdoc">     *  The default function to be called when a notification client responds
</span>   348    <span class="xdoc">     *  with any value other than Power_NOTIFYDONE.
</span>   349    <span class="xdoc">     *
</span>   350    <span class="xdoc">     *  The default behavior of this function is to spin in an infinite loop.
</span>   351    <span class="xdoc">     */</span>
   352        Void defaultNotifyTrapFunc();
   353    
   354        <span class="xdoc">/*!
</span>   355    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   356    <span class="xdoc">     *  ======== startFirstMeasurement ========
</span>   357    <span class="xdoc">     *  Start the first RCOSC calibration measurement
</span>   358    <span class="xdoc">     */</span>
   359        Void injectCalibration();
   360    
   361        <span class="xdoc">/*!
</span>   362    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   363    <span class="xdoc">     *  ======== auxISR ========
</span>   364    <span class="xdoc">     *  ISR for AUX combined interrupt for TDC (for RCOSC calibration)
</span>   365    <span class="xdoc">     */</span>
   366        Void auxISR(UArg arg);
   367    
   368        <span class="xdoc">/*!
</span>   369    <span class="xdoc">     *  ======== getClockHandle ========
</span>   370    <span class="xdoc">     *  Get the handle of the Clock object created for scheduling wakeups.
</span>   371    <span class="xdoc">     */</span>
   372        Clock.Handle getClockHandle();
   373    
   374        <span class="xdoc">/*!
</span>   375    <span class="xdoc">     *  ======== doWFI ========
</span>   376    <span class="xdoc">     *  A power policy function that invokes wait-for-interrupt (WFI)
</span>   377    <span class="xdoc">     *  during idle time.
</span>   378    <span class="xdoc">     *
</span>   379    <span class="xdoc">     *  This is the most basic power policy function, which will invoke
</span>   380    <span class="xdoc">     *  WFI upon entry to the Idle loop.  This is the default policy function
</span>   381    <span class="xdoc">     *  that is invoked when CPU idling is enabled with the {<b>@link</b> #idle idle}
</span>   382    <span class="xdoc">     *  configuration parameter:
</span>   383    <span class="xdoc">     *
</span>   384    <span class="xdoc">     *  <b>@p(code)</b>
</span>   385    <span class="xdoc">     *  Power.idle = true;
</span>   386    <span class="xdoc">     *  <b>@p</b>
</span>   387    <span class="xdoc">     *
</span>   388    <span class="xdoc">     */</span>
   389        Void doWFI();
   390    
   391        <span class="xdoc">/*!
</span>   392    <span class="xdoc">     *  ======== getConstraintInfo ========
</span>   393    <span class="xdoc">     *  Get a bitmask representing the aggregate of constraints that have been
</span>   394    <span class="xdoc">     *  declared.
</span>   395    <span class="xdoc">     *
</span>   396    <span class="xdoc">     *  This function returns a bitmask indicating the constraints that are
</span>   397    <span class="xdoc">     *  currently declared to the Power module (via previous calls to
</span>   398    <span class="xdoc">     *  {<b>@link</b> #setConstraint Power_setConstraint()}).  For each constraint
</span>   399    <span class="xdoc">     *  (of type {<b>@link</b> #Constraint Power_Constraint}) that is currently
</span>   400    <span class="xdoc">     *  declared, the corresponding bit in the bitmask will be set.  For
</span>   401    <span class="xdoc">     *  example, if two clients have declared Power_SB_DISALLOW, and one has
</span>   402    <span class="xdoc">     *  declared Power_SB_VIMS_CACHE_RETAIN, then the returned bitmask
</span>   403    <span class="xdoc">     *  will have the value: Power_SB_DISALLOW | Power_SB_VIMS_CACHE_RETAIN
</span>   404    <span class="xdoc">     *
</span>   405    <span class="xdoc">     *  <b>@b(returns)</b>     A bitmask representing all currently declared
</span>   406    <span class="xdoc">     *                  constraints
</span>   407    <span class="xdoc">     */</span>
   408        UInt32 getConstraintInfo();
   409    
   410        <span class="xdoc">/*!
</span>   411    <span class="xdoc">     *  ======== getDependencyCount ========
</span>   412    <span class="xdoc">     *  Get the count of dependencies that are currently declared upon a
</span>   413    <span class="xdoc">     *  resource.
</span>   414    <span class="xdoc">     *
</span>   415    <span class="xdoc">     *  This function returns the number of dependencies that are currently
</span>   416    <span class="xdoc">     *  declared upon a resource.
</span>   417    <span class="xdoc">     *
</span>   418    <span class="xdoc">     *  <b>@param(resourceID)</b>  The resource identifier, as specified in the
</span>   419    <span class="xdoc">     *                      device-specific header file
</span>   420    <span class="xdoc">     *
</span>   421    <span class="xdoc">     *  <b>@b(returns)</b>     The number of dependencies currently declared upon this
</span>   422    <span class="xdoc">     *                  resourceID
</span>   423    <span class="xdoc">     */</span>
   424        UInt32 getDependencyCount(UInt8 resourceID);
   425    
   426        <span class="xdoc">/*!
</span>   427    <span class="xdoc">     *  ======== getTransitionState ========
</span>   428    <span class="xdoc">     *  Get the current Power module transition state.
</span>   429    <span class="xdoc">     *
</span>   430    <span class="xdoc">     *  <b>@b(returns)</b>     The current transition state, of type
</span>   431    <span class="xdoc">     *                   {<b>@link</b> #TransitionState Power_TransitionState}
</span>   432    <span class="xdoc">     */</span>
   433        TransitionState getTransitionState();
   434    
   435        <span class="xdoc">/*!
</span>   436    <span class="xdoc">     *  ======== getTicksUntilWakeup ========
</span>   437    <span class="xdoc">     *  Get the number of system ticks until the next scheduled wakeup event
</span>   438    <span class="xdoc">     *
</span>   439    <span class="xdoc">     *  <b>@b(returns)</b>     The number of system ticks (i.e.,
</span>   440    <span class="xdoc">     *                  {<b>@link</b> ti.sysbios.knl.Clock Clock} module) ticks
</span>   441    <span class="xdoc">     *                  until the next scheduled wakeup
</span>   442    <span class="xdoc">     */</span>
   443        UInt32 getTicksUntilWakeup();
   444    
   445        <span class="xdoc">/*!
</span>   446    <span class="xdoc">     *  ======== getTransitionLatency ========
</span>   447    <span class="xdoc">     *  Get the minimal transition latency for a sleep state, in units of
</span>   448    <span class="xdoc">     *  system Clock ticks.
</span>   449    <span class="xdoc">     *
</span>   450    <span class="xdoc">     *  Note that the reported latency is the device transition latency for
</span>   451    <span class="xdoc">     *  the specified sleep state.  This latency value does not include any
</span>   452    <span class="xdoc">     *  additional software induced latency, for example, that due to
</span>   453    <span class="xdoc">     *  notifications of the power transition to drivers.
</span>   454    <span class="xdoc">     *
</span>   455    <span class="xdoc">     *  <b>@param(sleepState)</b>  The {<b>@link</b> #SleepState sleepState} whose transition
</span>   456    <span class="xdoc">     *  latency is to be reported (e.g., Power_STANDBY)
</span>   457    <span class="xdoc">     *
</span>   458    <span class="xdoc">     *  <b>@param(type)</b>  The {<b>@link</b> #LatencyType type} of latency to be
</span>   459    <span class="xdoc">     *  reported
</span>   460    <span class="xdoc">     *
</span>   461    <span class="xdoc">     *  <b>@b(returns)</b>     The transition latency, in units of
</span>   462    <span class="xdoc">     *                  {<b>@link</b> ti.sysbios.knl.Clock Clock} ticks.
</span>   463    <span class="xdoc">     */</span>
   464        UInt32 getTransitionLatency(SleepState sleepState, LatencyType type);
   465    
   466        <span class="xdoc">/*!
</span>   467    <span class="xdoc">     *  ======== getXoscStartupTime ========
</span>   468    <span class="xdoc">     *  Get the estimated crystal oscillator startup time, in units of
</span>   469    <span class="xdoc">     *  microseconds.
</span>   470    <span class="xdoc">     *
</span>   471    <span class="xdoc">     *  <b>@param(timeUntilWakeupInMs)</b>  The estimated time until the next wakeup
</span>   472    <span class="xdoc">     *                  event, in units of milliseconds
</span>   473    <span class="xdoc">     *
</span>   474    <span class="xdoc">     *  <b>@b(returns)</b>     The estimated crystal oscillator startup latency, in
</span>   475    <span class="xdoc">     *                  units of microseconds.
</span>   476    <span class="xdoc">     *
</span>   477    <span class="xdoc">     *  <b>@a(Note)</b>  The estimated time until wakeup is in units of milliseconds,
</span>   478    <span class="xdoc">     *            but the the estimate crystal startup time is in microseconds.
</span>   479    <span class="xdoc">     */</span>
   480        UInt32 getXoscStartupTime(UInt32 timeUntilWakeupInMs);
   481    
   482        <span class="xdoc">/*!
</span>   483    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   484    <span class="xdoc">     *  ======== isStableXOSC_HF ========
</span>   485    <span class="xdoc">     *  Check if XOSC_HF has stabilized.
</span>   486    <span class="xdoc">     *
</span>   487    <span class="xdoc">     *  <b>@b(returns)</b>     TRUE if XOSC_HF has stabilized, FALSE if hasn't
</span>   488    <span class="xdoc">     *                  stabilized yet
</span>   489    <span class="xdoc">     */</span>
   490        Bool isStableXOSC_HF();
   491    
   492        <span class="xdoc">/*!
</span>   493    <span class="xdoc">     *  ======== releaseConstraint ========
</span>   494    <span class="xdoc">     *  Release a constraint that was previously declared with {<b>@link</b>
</span>   495    <span class="xdoc">     *  #setConstraint Power_setConstraint()}.
</span>   496    <span class="xdoc">     *
</span>   497    <span class="xdoc">     *  This function releases a constraint that was previously declared with
</span>   498    <span class="xdoc">     *  {<b>@link</b> #setConstraint Power_setConstraint()}.  For example, if a device
</span>   499    <span class="xdoc">     *  driver is starting a transaction and wants to prohibit activation of
</span>   500    <span class="xdoc">     *  the Power_STANDBY sleep mode, it uses {<b>@link</b> #setConstraint
</span>   501    <span class="xdoc">     *  Power_setConstraint} to declare the constraint, before starting
</span>   502    <span class="xdoc">     *  the transaction.  When the transaction completes, the driver calls
</span>   503    <span class="xdoc">     *  this function to release the constraint, and allow the power manager
</span>   504    <span class="xdoc">     *  to once again transition into the Power_STANDBY sleep mode, if
</span>   505    <span class="xdoc">     *  appropriate.
</span>   506    <span class="xdoc">     *
</span>   507    <span class="xdoc">     *  <b>@param(constraint)</b>  The constraint being released, of type {<b>@link</b>
</span>   508    <span class="xdoc">     *                  #Constraint Power_Constraint}
</span>   509    <span class="xdoc">     *
</span>   510    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   511    <span class="xdoc">     *  Power_releaseConstraint() must not be called more than
</span>   512    <span class="xdoc">     *  Power_setConstraint() has been called for the same constraint.  If
</span>   513    <span class="xdoc">     *  asserts are enabled, one will be generated in this case.
</span>   514    <span class="xdoc">     */</span>
   515        Void releaseConstraint(Constraint constraint);
   516    
   517        <span class="xdoc">/*!
</span>   518    <span class="xdoc">     *  ======== releaseDependency ========
</span>   519    <span class="xdoc">     *  Release a dependency that had been previously declared with {<b>@link</b>
</span>   520    <span class="xdoc">     *  #setDependency Power_setDependency()}.
</span>   521    <span class="xdoc">     *
</span>   522    <span class="xdoc">     *  This function is the companion to {<b>@link</b> #setDependency
</span>   523    <span class="xdoc">     *  Power_setDependency()}.  If this release is for the last outstanding
</span>   524    <span class="xdoc">     *  dependency upon the resource, the resource will be de-activated as part
</span>   525    <span class="xdoc">     *  of this function call.
</span>   526    <span class="xdoc">     *
</span>   527    <span class="xdoc">     *  <b>@param(resourceID)</b>  The resource identifier, as specified in the
</span>   528    <span class="xdoc">     *                      device-specific header file
</span>   529    <span class="xdoc">     *
</span>   530    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   531    <span class="xdoc">     *  Power_releaseDependency() must not be called more than
</span>   532    <span class="xdoc">     *  Power_setDependency() has been called for the same resource.  If
</span>   533    <span class="xdoc">     *  asserts are enabled, one will be generated in this case.
</span>   534    <span class="xdoc">     */</span>
   535        Void releaseDependency(UInt8 resourceID);
   536    
   537        <span class="xdoc">/*!
</span>   538    <span class="xdoc">     *  ======== registerNotify ========
</span>   539    <span class="xdoc">     *  Register a function to be called upon a specific power event.
</span>   540    <span class="xdoc">     *
</span>   541    <span class="xdoc">     *  This function registers a function to be called when a
</span>   542    <span class="xdoc">     *  Power event occurs. Registrations and the corresponding notifications
</span>   543    <span class="xdoc">     *  are processed in first-in-first-out (FIFO) order. The function
</span>   544    <span class="xdoc">     *  registered must behave as described below.
</span>   545    <span class="xdoc">     *
</span>   546    <span class="xdoc">     *  The pNotifyObj parameter is a pointer to a pre-allocated, opaque
</span>   547    <span class="xdoc">     *  object that will be used by Power to support the notification.  This
</span>   548    <span class="xdoc">     *  object could be dynamically allocated, or declared as a global object.
</span>   549    <span class="xdoc">     *  Power_registerNotify() will properly initialized the object's fields as
</span>   550    <span class="xdoc">     *  appropriate; the caller just needs to provide a pointer to this
</span>   551    <span class="xdoc">     *  pre-existing object.
</span>   552    <span class="xdoc">     *
</span>   553    <span class="xdoc">     *  The eventType parameter identifies the type of power event for which
</span>   554    <span class="xdoc">     *  the notify function being registered is to be called.  This parameter
</span>   555    <span class="xdoc">     *  is treated as a bitmask, so multiple event types can be registered for
</span>   556    <span class="xdoc">     *  a common function.  The event types are enumerated as {<b>@link</b> #Event
</span>   557    <span class="xdoc">     *  Power_Event}.  For example, to call the specified function when
</span>   558    <span class="xdoc">     *  both the entering standby and the awake from standby events occur,
</span>   559    <span class="xdoc">     *  eventType should be specified as:
</span>   560    <span class="xdoc">     *  (Power_ENTERING_STANDBY | Power_AWAKE_STANDBY)
</span>   561    <span class="xdoc">     *
</span>   562    <span class="xdoc">     *  The clientArg parameter is an arbitrary argument to be passed to the
</span>   563    <span class="xdoc">     *  client upon notification. This argument may allow one notify function
</span>   564    <span class="xdoc">     *  to be used by multiple instances of a driver (that is, the clientArg
</span>   565    <span class="xdoc">     *  can be used to identify the instance of the driver that is being
</span>   566    <span class="xdoc">     *  notified).
</span>   567    <span class="xdoc">     *
</span>   568    <span class="xdoc">     *  The notifyFxn parameter specifies the function to call when the
</span>   569    <span class="xdoc">     *  specified Power event occurs. The notifyFxn must implement
</span>   570    <span class="xdoc">     *  the following signature:
</span>   571    <span class="xdoc">     *
</span>   572    <span class="xdoc">     *      status = notifyFxn(eventType, clientArg);
</span>   573    <span class="xdoc">     *
</span>   574    <span class="xdoc">     *  Where: eventType (type of {<b>@link</b> #Event Power_Event}) is the event
</span>   575    <span class="xdoc">     *  being signalled, and clientArg is the abitrary argument specified
</span>   576    <span class="xdoc">     *  by the client at registration.  Note that multipe types of events
</span>   577    <span class="xdoc">     *  can be specified when registering the notification callback function,
</span>   578    <span class="xdoc">     *  but when the callback function is actually called by Power, only a
</span>   579    <span class="xdoc">     *  single eventType will be specified for the callback (i.e., the current
</span>   580    <span class="xdoc">     *  event).
</span>   581    <span class="xdoc">     *
</span>   582    <span class="xdoc">     *  The client notification function being registered must return one of the
</span>   583    <span class="xdoc">     *  following constants as a status value, of type {<b>@link</b> #NotifyResponse
</span>   584    <span class="xdoc">     *  Power_NotifyResponse}: Power_NOTIFYDONE if the client processed the
</span>   585    <span class="xdoc">     *  notification function successfully, or Power_NOTIFYERROR if the
</span>   586    <span class="xdoc">     *  notification cannot be processed (e.g., if an internal client error
</span>   587    <span class="xdoc">     *  occurs).
</span>   588    <span class="xdoc">     *
</span>   589    <span class="xdoc">     *  <b>@param(pNotifyObj)</b>  The notify object to be used for queuing
</span>   590    <span class="xdoc">     *                      of the notification callback function
</span>   591    <span class="xdoc">     *
</span>   592    <span class="xdoc">     *  <b>@param(eventTypes)</b>  The type or types of {<b>@link</b> #Event Power_Event} to
</span>   593    <span class="xdoc">     *                      be notified of
</span>   594    <span class="xdoc">     *
</span>   595    <span class="xdoc">     *  <b>@param(notifyFxn)</b>  The callback function Power should call to notify
</span>   596    <span class="xdoc">     *                     the client of the event
</span>   597    <span class="xdoc">     *
</span>   598    <span class="xdoc">     *  <b>@param(clientArg)</b>  A client-defined argument to pass with the notifyFxn
</span>   599    <span class="xdoc">     *                     call
</span>   600    <span class="xdoc">     *
</span>   601    <span class="xdoc">     *  <b>@param(arg)</b>        For future use, should be specified as:
</span>   602    <span class="xdoc">     *                     NULL
</span>   603    <span class="xdoc">     *
</span>   604    <span class="xdoc">     *  <b>@b(returns)</b>     Power_SOK if the registration succeeded
</span>   605    <span class="xdoc">     *
</span>   606    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EINVALIDPOINTER if either pNotifyObj or notifyFxn
</span>   607    <span class="xdoc">     *                  were NULL
</span>   608    <span class="xdoc">     *
</span>   609    <span class="xdoc">     */</span>
   610        Status registerNotify(NotifyObj * pNotifyObj, UInt32 eventTypes,
   611            Fxn notifyFxn, UArg clientArg, UArg arg);
   612    
   613        <span class="xdoc">/*!
</span>   614    <span class="xdoc">     *  ======== setConstraint ========
</span>   615    <span class="xdoc">     *  Declare an operational constraint.
</span>   616    <span class="xdoc">     *
</span>   617    <span class="xdoc">     *  Before taking certain actions, Power checks to see if the requested
</span>   618    <span class="xdoc">     *  action would conflict with a client-declared constraint. If the
</span>   619    <span class="xdoc">     *  action does conflict, Power will not proceed with the request.
</span>   620    <span class="xdoc">     *  This is the function that allows clients to declare their constraints
</span>   621    <span class="xdoc">     *  with Power.
</span>   622    <span class="xdoc">     *
</span>   623    <span class="xdoc">     *  It is critical that clients call {<b>@link</b> #releaseConstraint
</span>   624    <span class="xdoc">     *  Power_releaseConstraint()} when operational constraints no longer
</span>   625    <span class="xdoc">     *  exists. Otherwise, Power may be left unnecessarily restricted from
</span>   626    <span class="xdoc">     *  activating power savings.
</span>   627    <span class="xdoc">     *
</span>   628    <span class="xdoc">     *  <b>@param(constraint)</b>  The constraint being declared, of type {<b>@link</b>
</span>   629    <span class="xdoc">     *                  #Constraint Power_Constraint}
</span>   630    <span class="xdoc">     */</span>
   631        Void setConstraint(Constraint constraint);
   632    
   633        <span class="xdoc">/*!
</span>   634    <span class="xdoc">     *  ======== setDependency ========
</span>   635    <span class="xdoc">     *  Declare a dependency upon a power-manageable resource.
</span>   636    <span class="xdoc">     *
</span>   637    <span class="xdoc">     *  This function declares a dependency upon a resource.  If the resource
</span>   638    <span class="xdoc">     *  had been inactive, it will be activated during this function call.
</span>   639    <span class="xdoc">     *
</span>   640    <span class="xdoc">     *  This function is the companion to {<b>@link</b> #releaseDependency
</span>   641    <span class="xdoc">     *  Power_releaseDependency()}.
</span>   642    <span class="xdoc">     *
</span>   643    <span class="xdoc">     *  <b>@param(resourceID)</b>  The resource identifier, as specified in the
</span>   644    <span class="xdoc">     *                      device-specific header file (for example,
</span>   645    <span class="xdoc">     *                      PERIPH_UART0, as defined in PowerCC2650.h)
</span>   646    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   647    <span class="xdoc">     *  When a dependency is declared upon a resource for the first time, the
</span>   648    <span class="xdoc">     *  resource will be activated before the call to Power_setDependency()
</span>   649    <span class="xdoc">     *  returns to the caller.  There is only one exception to this rule:
</span>   650    <span class="xdoc">     *  the XOSC_HF resource for CC26xx.  The latency to startup the crystal
</span>   651    <span class="xdoc">     *  is much longer than that for other resources. To avoid blocking in
</span>   652    <span class="xdoc">     *  Power_setDependency() for this duration, for the XOSC_HF resource
</span>   653    <span class="xdoc">     *  only, Power_setDependency() will return quickly, after initiating the
</span>   654    <span class="xdoc">     *  activation of XOSC_HF.  Once the switchover to the XOSC_HF
</span>   655    <span class="xdoc">     *  happens, notifications will be sent to clients registered for the
</span>   656    <span class="xdoc">     *  Power_XOSC_HF_SWITCHED event.
</span>   657    <span class="xdoc">     *
</span>   658    <span class="xdoc">     *  Power_setDependency() will return a Boolean status to indicate if
</span>   659    <span class="xdoc">     *  the resource is active as the function is initiating a return to the
</span>   660    <span class="xdoc">     *  caller.  For all resources other than XOSC_HF, the return status will
</span>   661    <span class="xdoc">     *  always be TRUE, because the resource will be active before the return
</span>   662    <span class="xdoc">     *  to the caller.  For XOSC_HF, the return status may be TRUE if the
</span>   663    <span class="xdoc">     *  XOSC_HF is already active.  For example, if XOSC_HF was already
</span>   664    <span class="xdoc">     *  activated with an earlier call to Power_setDependency(XOSC_HF).
</span>   665    <span class="xdoc">     *  If the return status is FALSE, this indicates to the caller that
</span>   666    <span class="xdoc">     *  XOSC_HF hadn't been switched by the time the function initiated a
</span>   667    <span class="xdoc">     *  return, and that the caller should wait for the Power_XOSC_HF_SWITCHED
</span>   668    <span class="xdoc">     *  event notification before proceeding to the work that requires XOSC_HF
</span>   669    <span class="xdoc">     *  to be active.
</span>   670    <span class="xdoc">     *
</span>   671    <span class="xdoc">     *  The recommended sequence for a caller to activate XOSC_HF is:
</span>   672    <span class="xdoc">     *
</span>   673    <span class="xdoc">     *
</span>   674    <span class="xdoc">     *      1) Caller registers for a Power_XOSC_HF_SWITCHED notification.
</span>   675    <span class="xdoc">     *         For example, the specified callback function might set a global
</span>   676    <span class="xdoc">     *         flag, which the caller can check to see if the notification
</span>   677    <span class="xdoc">     *         occurred.
</span>   678    <span class="xdoc">     *
</span>   679    <span class="xdoc">     *      2) Caller invokes: status = Power_setDependency(XOSC_HF);
</span>   680    <span class="xdoc">     *
</span>   681    <span class="xdoc">     *
</span>   682    <span class="xdoc">     *      3) Caller checks status to see if XOSC_HF is active yet
</span>   683    <span class="xdoc">     *
</span>   684    <span class="xdoc">     *
</span>   685    <span class="xdoc">     *          - If status is TRUE, XOSC_HF is active, caller should proceed,
</span>   686    <span class="xdoc">     *            and NOT wait for a Power_XOSC_HF_SWITCHED notification
</span>   687    <span class="xdoc">     *
</span>   688    <span class="xdoc">     *          - Else, XOSC_HF wasn't activated yet, caller needs to wait
</span>   689    <span class="xdoc">     *            until the Power_XOSC_HF_SWITCHED event has been signaled.
</span>   690    <span class="xdoc">     *            Note that depending upon timing, the event may have been
</span>   691    <span class="xdoc">     *            signaled between the time the return status was determined
</span>   692    <span class="xdoc">     *            within Power_setDependency() and the time the caller
</span>   693    <span class="xdoc">     *            checks the return status.  The key point is that, when
</span>   694    <span class="xdoc">     *            the return status is FALSE, the Power_XOSC_HF_SWITCHED
</span>   695    <span class="xdoc">     *            notification WILL be sent (once the XOSC_HF is switched),
</span>   696    <span class="xdoc">     *            and the caller should wait for this notification before
</span>   697    <span class="xdoc">     *            proceeding with any work that requires XOSC_HF to be active.
</span>   698    <span class="xdoc">     *
</span>   699    <span class="xdoc">     *  <b>@b(returns)</b>     TRUE if resource is active
</span>   700    <span class="xdoc">     *
</span>   701    <span class="xdoc">     *  <b>@b(returns)</b>     FALSE if resource was not yet active when the function
</span>   702    <span class="xdoc">     *                  return was initiated
</span>   703    <span class="xdoc">     *
</span>   704    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   705    <span class="xdoc">     *  For the XOSC_HF resource (described above), the caller MUST wait for
</span>   706    <span class="xdoc">     *  XOSC_HF activation to complete before calling
</span>   707    <span class="xdoc">     *  Power_releaseDependency(XOSC_HF).
</span>   708    <span class="xdoc">     */</span>
   709        Bool setDependency(UInt8 resourceID);
   710    
   711        <span class="xdoc">/*!
</span>   712    <span class="xdoc">     *  ======== shutdown ========
</span>   713    <span class="xdoc">     *  Put the device into the SHUTDOWN state.
</span>   714    <span class="xdoc">     *
</span>   715    <span class="xdoc">     *  This function will transition the device into the SHUTDOWN state.
</span>   716    <span class="xdoc">     *  Before the actual device transtion is initiated, notifications will
</span>   717    <span class="xdoc">     *  be sent to any clients who've registered for the
</span>   718    <span class="xdoc">     *  Power_ENTERING_SHUTDOWN event (via {<b>@link</b> #registerNotify
</span>   719    <span class="xdoc">     *  Power_registerNotify()}).  Once notifications have been completed, the
</span>   720    <span class="xdoc">     *  device shutdown will commence.
</span>   721    <span class="xdoc">     *
</span>   722    <span class="xdoc">     *  If the device is successfully transitioned to SHUTDOWN, this function
</span>   723    <span class="xdoc">     *  call will never return.  Upon wakeup, the device and application will
</span>   724    <span class="xdoc">     *  be rebooted.  If the transition to SHUTDOWN is not successful, one of
</span>   725    <span class="xdoc">     *  the error codes listed above will be returned.
</span>   726    <span class="xdoc">     *
</span>   727    <span class="xdoc">     *  <b>@param(arg)</b>     Reserved for future use; currently unused
</span>   728    <span class="xdoc">     *
</span>   729    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EBUSY if Power is currently busy with another
</span>   730    <span class="xdoc">     *                  transition
</span>   731    <span class="xdoc">     *
</span>   732    <span class="xdoc">     *  <b>@b(returns)</b>     Power_ECHANGE_NOT_ALLOWED   if SHUTDOWN is disallowed
</span>   733    <span class="xdoc">     *                  due to the Power_SD_DISALLOW constraint having been
</span>   734    <span class="xdoc">     *                  declared
</span>   735    <span class="xdoc">     *
</span>   736    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EFAIL   if a notification error occurred
</span>   737    <span class="xdoc">     *
</span>   738    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   739    <span class="xdoc">     *  This function will not prepare I/O pins for the device
</span>   740    <span class="xdoc">     *  shutdown state.  The application needs to do the appropriate
</span>   741    <span class="xdoc">     *  I/O preparation before calling this API.
</span>   742    <span class="xdoc">     */</span>
   743        Status shutdown(UArg arg);
   744    
   745        <span class="xdoc">/*!
</span>   746    <span class="xdoc">     *  ======== sleep ========
</span>   747    <span class="xdoc">     *  Put the CPU into a sleep state.
</span>   748    <span class="xdoc">     *
</span>   749    <span class="xdoc">     *  This function transitions the device into and out of a sleep state.
</span>   750    <span class="xdoc">     *  The function returns to the caller when the device is awake again.
</span>   751    <span class="xdoc">     *
</span>   752    <span class="xdoc">     *  <b>@param(sleepState)</b>  The sleep state to be entered, of type
</span>   753    <span class="xdoc">     *                      {<b>@link</b> #sleepState Power_sleepState}
</span>   754    <span class="xdoc">     *
</span>   755    <span class="xdoc">     *  <b>@param(arg0)</b>    Reserved for future use; currently unused
</span>   756    <span class="xdoc">     *
</span>   757    <span class="xdoc">     *  <b>@param(arg1)</b>    Reserved for future use; currently unused
</span>   758    <span class="xdoc">     *
</span>   759    <span class="xdoc">     *  <b>@b(returns)</b>     Power_SOK upon success, the device is awake
</span>   760    <span class="xdoc">     *
</span>   761    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EBUSY if Power is currently busy with another
</span>   762    <span class="xdoc">     *                  transition
</span>   763    <span class="xdoc">     *
</span>   764    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EFAIL if a general failure occurred and the
</span>   765    <span class="xdoc">     *                  device was not transitioned into sleep
</span>   766    <span class="xdoc">     *
</span>   767    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   768    <span class="xdoc">     *  Power_sleep() is intended to be called from a Power Policy
</span>   769    <span class="xdoc">     *  implementation function.  This API is not normally called directly
</span>   770    <span class="xdoc">     *  by an application.
</span>   771    <span class="xdoc">     *
</span>   772    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   773    <span class="xdoc">     *  Power_sleep() does not check the constraints that might prohibit a
</span>   774    <span class="xdoc">     *  sleep transition.  The caller of Power_sleep() must validate the
</span>   775    <span class="xdoc">     *  transition versus active constraints, prior to calling Power_sleep().
</span>   776    <span class="xdoc">     */</span>
   777        Status sleep(SleepState sleepState, UArg arg0, UArg arg1);
   778    
   779        <span class="xdoc">/*!
</span>   780    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   781    <span class="xdoc">     *  ======== switchXOSC_HF ========
</span>   782    <span class="xdoc">     *  Switch to enable XOSC_HF.
</span>   783    <span class="xdoc">     */</span>
   784        Void switchXOSC_HF();
   785    
   786        <span class="xdoc">/*!
</span>   787    <span class="xdoc">     *  ======== unregisterNotify ========
</span>   788    <span class="xdoc">     *  Unregister for Power event notifications.
</span>   789    <span class="xdoc">     *
</span>   790    <span class="xdoc">     *  This function unregisters for event notifications that were previously
</span>   791    <span class="xdoc">     *  registered with {<b>@link</b> #registerNotify Power_registerNotify()}.
</span>   792    <span class="xdoc">     *
</span>   793    <span class="xdoc">     *  <b>@param(pNotifyObj)</b>  The notification object that was previously
</span>   794    <span class="xdoc">     *                      used with {<b>@link</b> #registerNotify
</span>   795    <span class="xdoc">     *                      Power_registerNotify()} to register for
</span>   796    <span class="xdoc">     *                      event notifications
</span>   797    <span class="xdoc">     */</span>
   798        Void unregisterNotify(NotifyObj * pNotifyObj);
   799    
   800    
   801        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   802        @XmlDtd
   803        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   804            String    ConstraintsMask;
   805        };
   806    
   807        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   808        @Facet
   809        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   810            ViewInfo.create({
   811                viewMap: [
   812                [
   813                    <span class="string">'Module'</span>,
   814                    {
   815                        type: ViewInfo.MODULE,
   816                        viewInitFxn: <span class="string">'viewInitModule'</span>,
   817                        structName: <span class="string">'ModuleView'</span>
   818                    }
   819                ],
   820                ]
   821            });
   822    
   823        <span class="xdoc">/*!
</span>   824    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   825    <span class="xdoc">     *  ======== idleCPU ========
</span>   826    <span class="xdoc">     *  Function used to automatically idle the CPU in the Idle loop.
</span>   827    <span class="xdoc">     *
</span>   828    <span class="xdoc">     *  When the 'idle' configuration parameter is set, this function will
</span>   829    <span class="xdoc">     *  be added to the list of Idle loop functions.  When called from the
</span>   830    <span class="xdoc">     *  Idle loop, it will invoke the wait for interrupt (WFI) instruction,
</span>   831    <span class="xdoc">     *  to idle the CPU until the next interrupt occurs.
</span>   832    <span class="xdoc">     */</span>
   833        Void idleCPU();
   834    
   835    <span class=key>internal</span>:
   836    
   837        <span class="comment">/*
</span>   838    <span class="comment">     *  ======== abs ========
</span>   839    <span class="comment">     */</span>
   840        Int abs(Int i);
   841    
   842        <span class="comment">/*
</span>   843    <span class="comment">     *  ======== calibrateRcoscHf1 ========
</span>   844    <span class="comment">     */</span>
   845        Void calibrateRcoscHf1(Int32 tdcResult);
   846    
   847        <span class="comment">/*
</span>   848    <span class="comment">     *  ======== calibrateRcoscHf2 ========
</span>   849    <span class="comment">     */</span>
   850        Void calibrateRcoscHf2(Int32 tdcResult);
   851    
   852        <span class="comment">/*
</span>   853    <span class="comment">     *  ======== doCalibrate ========
</span>   854    <span class="comment">     */</span>
   855        Void doCalibrate();
   856    
   857        <span class="comment">/*
</span>   858    <span class="comment">     *  ======== getTdcSemaphore ========
</span>   859    <span class="comment">     */</span>
   860        Bool getTdcSemaphore();
   861    
   862        <span class="comment">/*
</span>   863    <span class="comment">     *  ======== initateCalibration ========
</span>   864    <span class="comment">     */</span>
   865        Bool initiateCalibration();
   866    
   867        <span class="comment">/*
</span>   868    <span class="comment">     *  ======== isDependencyActive ========
</span>   869    <span class="comment">     */</span>
   870        Bool isDependencyActive(UInt8 resourceID);
   871    
   872        <span class="comment">/*
</span>   873    <span class="comment">     *  ======== LF_clockFunc ========
</span>   874    <span class="comment">     */</span>
   875        Void LF_clockFunc(UArg arg);
   876    
   877        <span class="comment">/*
</span>   878    <span class="comment">     *  ======== NOP ========
</span>   879    <span class="comment">     */</span>
   880        UInt NOP(UInt action);
   881    
   882        <span class="comment">/*
</span>   883    <span class="comment">     *  ======== notify ========
</span>   884    <span class="comment">     */</span>
   885        Status notify(Event eventType);
   886    
   887        <span class="comment">/*
</span>   888    <span class="comment">     *  ======== RCOSC_clockFunc ========
</span>   889    <span class="comment">     */</span>
   890        Void RCOSC_clockFunc(UArg arg);
   891    
   892        <span class="comment">/*
</span>   893    <span class="comment">     *  ======== RFCORECLKS ========
</span>   894    <span class="comment">     */</span>
   895        UInt RFCORECLKS(UInt action);
   896    
   897        <span class="comment">/*
</span>   898    <span class="comment">     *  ======== scaleRndInf ========
</span>   899    <span class="comment">     */</span>
   900        Int32 scaleRndInf(Int32 x);
   901    
   902        <span class="comment">/*
</span>   903    <span class="comment">     *  ======== serviceNotifyQ ========
</span>   904    <span class="comment">     */</span>
   905        NotifyResponse serviceNotifyQ(Event eventType);
   906    
   907        <span class="comment">/*
</span>   908    <span class="comment">     *  ======== updateSubSecInc ========
</span>   909    <span class="comment">     */</span>
   910        Void updateSubSecInc(UInt32 tdcResult);
   911    
   912        <span class="comment">/*
</span>   913    <span class="comment">     *  ======== XOSC_HF ========
</span>   914    <span class="comment">     */</span>
   915        UInt XOSC_HF(UInt action);
   916    
   917        <span class="comment">/*
</span>   918    <span class="comment">     *  ======== XOSC_HF_xoscClockFunc ========
</span>   919    <span class="comment">     */</span>
   920        Void XOSC_HF_clockFunc(UArg arg);
   921    
   922        <span class="comment">/*
</span>   923    <span class="comment">     *  ======== Module_State ========
</span>   924    <span class="comment">     */</span>
   925        <span class=key>struct</span> Module_State {
   926            UInt32 constraintsMask;
   927            Queue.Object notifyQ;        <span class="comment">/* event notification queue */</span>
   928            Clock.Object clockObj;       <span class="comment">/* Clock object for scheduling wakeups */</span>
   929            Clock.Object xoscClockObj;   <span class="comment">/* Clock object for XOSC_HF switching */</span>
   930            Clock.Object lfClockObj;     <span class="comment">/* Clock object for LF clock check */</span>
   931            Clock.Handle calClockHandle; <span class="comment">/* Clock object for RCOSC calibration */</span>
   932            Int32 nDeltaFreqCurr;        <span class="comment">/* RCOSC calibration variable */</span>
   933            Int32 nCtrimCurr;            <span class="comment">/* RCOSC calibration variable */</span>
   934            Int32 nCtrimFractCurr;       <span class="comment">/* RCOSC calibration variable */</span>
   935            Int32 nCtrimNew;             <span class="comment">/* RCOSC calibration variable */</span>
   936            Int32 nCtrimFractNew;        <span class="comment">/* RCOSC calibration variable */</span>
   937            TransitionState state;       <span class="comment">/* current transition state */</span>
   938            Bool xoscPending;            <span class="comment">/* is XOSC_HF activation in progress? */</span>
   939            Bool calLF;                  <span class="comment">/* calibrate RCOSC_LF? */</span>
   940            UInt8 hwiState;              <span class="comment">/* calibration AUX ISR state */</span>
   941            Bool busyCal;                <span class="comment">/* already busy calibrating */</span>
   942            UInt8 calStep;               <span class="comment">/* current calibration step */</span>
   943            Bool firstLF;                <span class="comment">/* is this first LF calibration? */</span>
   944            volatile UInt8 * constraintCounts; <span class="comment">/* constraint counts array */</span>
   945            volatile UInt8 * resourceCounts;   <span class="comment">/* to resource ref counts array */</span>
   946            ResourceRecord * resourceDB;<span class="comment">/* resource database */</span>
   947            Fxn * resourceHandlers;     <span class="comment">/* resource special handler functions */</span>
   948        }
   949    }
</pre>
</body></html>
